---
title: "DFNA9 genotype ~ phenotype analysis"
author: "Cris Lanting"
date: "22/04/2020"
output:
  pdf_document: default
  html_notebook: default
  toc: 'true'
  fig_width: 6 
  fig_height: 4 
---
## Introduction
This [R Markdown](http://rmarkdown.rstudio.com) notebook is used to document the various aspects of the genotype-phenotype analysis in many subjects with hereditary hearing loss based on mutation in the DFNA9 gene. We have data collected [...].

## Load R-packages
```{r}
library(ggplot2)
library(drc)
library(sjPlot)
library("readxl")
library("nlme")
library(lme4)
library(knitr)
library(forcats)
library(tidyr)
library(dplyr)
```

## Load data and clean data-frames
Load data from Excel file and select only relevant columns/rows. The first analyses will be based on pure-tone average (PTA). The selected subset dataframe consists of the columns patient id (pid), group, age (Leeftijd), and the PTA (PTA54ADS).

```{r}
data_raw <- read_excel("../data/raw_data/database_20-04-2020.xlsx")
data_raw$group = factor(data_raw$Domain)
#leave out data with only n=1 dataset per domain/certain unpublished data.
data_subset <- subset(data_raw, Smits=='no' & Domainrec!=1 & group!="Ivd1")  
data <- subset(data_subset, select=c('pid', 'group', 'Leeftijd', 'PTA54ADS'))
data <- droplevels(data)
#data_raw %>% group_by(group) %>% summarize(count=n())
#head(data)
#check for NaNs in PTA and Leeftijd, should be 0.
nrow(data[is.na(data$PTA54ADS) | is.na(data$Leeftijd), ])
#number (n) of counts (i.e. audiograms) per subject (pid)
summarytable <- data %>% count(group, pid)
```
## Group description

In the group of DFNA9 patients we have some for which there is longitudinal data, i.e. multiple audiograms over time/age (Leeftijd).
First, create a table and histogram of number of measurements for each subject id (pid) across the groups
```{r}
num_meas_per_id <- aggregate(PTA54ADS ~ pid , data, function(x) length(unique(x)))
t1 <- table(num_meas_per_id$PTA54ADS)
```

In total there are `r sum(t1)` subjects with `r dim(data)[1]`  measurements; `r t1[1]` patients with only 1 measurement and `r sum(t1[2:12])` patients with 2 or more measurements, see e.g. table 1 or the histogram.

```{r}
kable(t1, caption = "Table 1. The number of subjects that each have n audiograms", col.names = c("# audiograms","# subjects"))
```


Now make a histogram of the number of audiograms across patients in each of the groups
```{r}
ggplot(data=summarytable, aes(x=n,fill=group)) + 
  geom_histogram(binwidth=1) +
  facet_wrap(~group) +
  xlab("# of measurements") +
  ylab("Frequency (# patients)") 
  png(file="results/hist.png")
  dev.off()
```

Relation of PTA with age for the different groups; connecting lines show longitudinal data of patients' PTA over time

```{r}
ggplot(data, aes(x = Leeftijd, y = PTA54ADS, group = pid, color = group)) + 
  #xlab("Age (years)") +
  #ylab("PTA (dB HL)") +
  geom_point(aes(colour = factor(group))) +
  geom_line(data=data, size=1, alpha = .3) +
  geom_hline(yintercept=0,linetype="dashed") +
  scale_x_continuous(breaks=seq(0,100,20)) +
  scale_y_reverse(breaks=seq(-10,130,20), limits=c(130,-10)) +
  #scale_y_reverse(limits=c(130,-10)) +
  xlab("Age (years)") +
  ylab("PTA (dB HL)") +
  theme_light() 
```
## Logistic fit of PTA with age
Perform non-linear fit; first focus on LCCL domain. 

```{r}
lccl = subset(data, group=="LCCL")
ggplot(lccl, aes(x=Leeftijd, y=PTA54ADS), group=pid, color=group) +
  xlab("Age (years)") +
  ylab("PTA (dB HL)") +
  geom_point(aes(colour = factor(group))) +
  geom_hline(yintercept=0,linetype="dashed") +
  scale_x_continuous(breaks=seq(0,100,20)) +
  scale_y_reverse(breaks=seq(-10,130,20), limits=c(130,-10)) +
  #scale_y_reverse(limits=c(130,-10)) +
  theme_light()
```

```{r}
lin_fit <- nls(PTA54ADS ~ a*Leeftijd + b, lccl)
summary(lin_fit)
```
```{r}
nls_fit <- nls(PTA54ADS ~ a*Leeftijd^b, lccl, start = list(a = 0.05, b = 1.5))
summary(nls_fit)
```
```{r}
startvec <- c(Asym = 120, xmid = 50, scal = 15)
nls_logis<- nls(PTA54ADS ~ SSlogis(Leeftijd, Asym, xmid, scal),
                 data=lccl,
                 start = startvec)
summary(nls_logis)
```

Compare power-law fit and the logistic functione and display the results
```{r}
anova(nls_fit,nls_logis)
```


```{r}
newdat = expand.grid(Leeftijd = seq(0, 100, by = 1))
newdat$lin <-predict(lin_fit, newdata = newdat)
newdat$pta_logistic <- predict(nls_logis,newdata = newdat)
newdat$pta_power <- predict(nls_fit,newdata = newdat)
#newdat
ggplot(lccl, aes(x=Leeftijd, y=PTA54ADS)) +
  geom_point(aes(colour = factor(group))) +
  geom_line(data = newdat, aes(y = lin), size = 1, col='blue') +
  geom_line(data = newdat, aes(y = pta_logistic), size = 1) +
  geom_line(data = newdat, aes(y = pta_power), size = 1, col='red') +
 
  geom_hline(yintercept=0,linetype="dashed") +
  scale_x_continuous(breaks=seq(0,100,20)) +
  scale_y_reverse(breaks=seq(-10,130,20), limits=c(130,-10)) +
  #scale_y_reverse(limits=c(130,-10)) +
  xlab("Age (years)") +
  ylab("PTA (dB HL)") +
  theme_light() 

```
            
As we can see, the logistic function (SSlogis) describes the data better than the power-law function (F = 18,9; p = 1.6 e-5)
This function has also been used in desribing the (frequency-specific) thresholds in Pauw et al., 2011 and will used in the subsequent sections.

## Group comparison
The main questions is whether the function that describes the PTA (dB HL) as a function of age (years) differs between the groups \@ref(fig:plot_pta_age_groups). 


Start with a group-fit; discarding grouping information
```{r}
fit0 <- nls(PTA54ADS ~ SSlogis(Leeftijd, Asym, xmid, scal), data=data)
summary(fit0)
coef(fit0)
```
Now, add a grouping-variable with the mid-point (xmid)

```{r}
# https://stats.stackexchange.com/questions/27273/how-do-i-fit-a-nonlinear-mixed-effects-model-for-repeated-measures-data-using-nl
# https://stats.stackexchange.com/questions/316801/how-to-compare-logistic-regression-curves
fit1 <- nls(PTA54ADS ~ SSlogis(Leeftijd, Asym, xmid[group], scal), 
            data=data,
            start=list(Asym=rep(120,1), xmid=rep(50,3), scal=rep(15,1)))
summary(fit1)
```
And add the scaling [scal] as a grouping variable; does it futher explain differences between groups?

```{r}
fit2 <- nls(PTA54ADS ~ SSlogis(Leeftijd, Asym, xmid[group], scal[group]), 
            data=data,
            start=list(Asym=rep(120,1), xmid=rep(50,3), scal=rep(15,3)))
summary(fit2)
```
```{r}
plot(profile(fit2))
```

And now add the asymptotic value of the fit (Leeftijd -> infinity) (Asym):
```{r}
fit3 <- nls(PTA54ADS ~ SSlogis(Leeftijd, Asym[group], xmid[group], scal[group]), 
            data=data,
            start=list(Asym=rep(120,3), xmid=rep(50,3), scal=rep(15,3)))
summary(fit3)
```

Now test the various models. Which of the parameters explain the data best?
```{r}
anova(fit0,fit1,fit2,fit3)
```
It turns out the both the variables [xmid] and [scale], i.e. the midpoint and slope at the midpoint significantly differ between the three groups, but that adding the asymptotic value does not describe the data signigicantly better. 


```{r}
newdat = expand.grid(Leeftijd = seq(0, 100, by = 1), group = c("LCCL","vWFA1","vWFA2"))
newdat$fit <- predict(fit2, newdata = newdat)
```
```{r}

ggplot(data, aes(x=Leeftijd, y=PTA54ADS, group = pid, color = group)) +
  geom_point(aes(colour = factor(group)),alpha = .7) +
  geom_line(data=data, size=1, alpha = .3) +
  geom_line(data = newdat, aes(y = fit, group = group, colour = factor(group)), size = 2) +
  geom_hline(yintercept=0,linetype="dashed") +
  scale_x_continuous(breaks=seq(0,100,20)) +
  scale_y_reverse(breaks=seq(-10,130,20), limits=c(130,-10)) +
  #scale_y_reverse(limits=c(130,-10)) +
  xlab("Age (years)") +
  ylab("PTA (dB HL)") +
  theme_light() 
```

Now perform fit on individual data by subsetting the data to keep individuals with more that 4 longitudinal datapoints. Is it the case that using a non-linear mixed-model approach may helpt us?

```{r}
#https://stackoverflow.com/questions/14439770/filter-rows-in-dataframe-by-number-of-rows-per-level-of-a-factor
pidlengths <- ave(as.numeric(data$pid), 
                     data$pid, FUN = length)
#df2 <- lccl[pidlengths > 5, ]
df2 <- data[pidlengths > 2, ]
with(df2, table(group))
```
```{r}
models <- nlsList(PTA54ADS ~ SSlogis(Leeftijd, Asym, xmid, scal) | pid, data = df2)
```

As we can see, some model-predictions failed; they end up with NaNs in the model fit list (nlslist); see e.g. pid 147

```{r}
data_id <- subset(df2, pid=="147")
data_id
ggplot(data=data_id,  aes(x=Leeftijd, y=PTA54ADS)) +
  geom_point() +
  geom_hline(yintercept=0,linetype="dashed") +
  scale_x_continuous(breaks=seq(0,100,20)) +
  scale_y_reverse(breaks=seq(-10,130,20), limits=c(130,-10)) +
  #scale_y_reverse(limits=c(130,-10)) +
  xlab("Age (years)") +
  ylab("PTA (dB HL)") +
  theme_light() 
```

Predict for all pid's the fit to the model and remove the pid's that give NaNs. Check how many subjects per group we end up with.

```{r}
df2$Pred <-predict(models)
df2_na <- na.omit(df2)
with(df2_na, table(group, pid))
```
We only keep the pid's from the LCCL group. The pid's in the other groups are not properly fitted.

```{r}
le <- unique(df2_na$pid)
#le
newdat = expand.grid(Leeftijd = seq(0, 100, by = 1), pid=le)
newdat$prednlm <-predict(models, newdata=newdat)
```

```{r}
#https://stackoverflow.com/questions/37122994/plotting-a-list-of-non-linear-regressions-with-ggplot
#https://aosmith.rbind.io/2018/11/16/plot-fitted-lines/
ip <- ggplot(data=df2_na,  aes(x=Leeftijd, y=PTA54ADS, colour = pid)) +
  geom_point() +
  geom_line(data=newdat,aes(y=prednlm)) +
  facet_wrap(~pid) +
  geom_hline(yintercept=0,linetype="dashed") +
  scale_x_continuous(breaks=seq(0,100,20)) +
  scale_y_reverse(breaks=seq(0,120,40), limits=c(130,-10)) +
  #scale_y_reverse(limits=c(130,-10)) +
  xlab("Age (years)") +
  ylab("PTA (dB HL)") +
  theme_light() 
ip
```

So, it seeems we can fit the data for individual subjects by some extent. It often 'fails' by over- or underestimating the tail (coef.lmlist Asym column). We can also plot it all in one figure.

```{r}
ggplot(data=df2_na,  aes(x=Leeftijd, y=PTA54ADS, colour = pid)) +
  geom_point() +
  geom_line(data=newdat,aes(y=prednlm, group = pid)) +
  geom_hline(yintercept=0,linetype="dashed") +
  scale_x_continuous(breaks=seq(0,100,20)) +
  scale_y_reverse(breaks=seq(-10,130,20), limits=c(130,-10)) +
  #scale_y_reverse(limits=c(130,-10)) +
  xlab("Age (years)") +
  ylab("PTA (dB HL)") +
  theme_light() 
```
Feed the remaining data into the non-linear mixed-models with the parameters Asym,  xmid, and scal as random factors.

```{r}
nm1 <- nlmer(PTA54ADS ~ SSlogis(Leeftijd, Asym, xmid, scal) ~ Asym + xmid + scal | pid, df2_na, start = c(Asym = 100, xmid = 60, scal = 15), corr = FALSE)
summary(nm1)
coef(nm1)
```

```{r}
require(lattice) 
qqmath(ranef(nm1, condVar=TRUE))

```

## Frequencey-specific analyses
Now subset the data to contain individual frequencies
```{r}
data_all <- subset(data_subset, select=c('pid', 'group', 'Leeftijd', '250.AD','500.AD', '1000.AD','2000.AD','4000.AD','8000.AD', '250.AS','500.AS', '1000.AS','2000.AS','4000.AS','8000.AS'))
head(data_all)
```
Convert 'wide' dataset into 'long' format using tidyr and remove NaNs

```{r}
tidier <- data_all %>%
  gather(f, dB, -pid, -group, -Leeftijd)
data_all_l <- tidier %>%
  separate(f, into = c("frequency", "ear"), sep = "\\.")
#head(data_all_l)
data_all_l$frequency = factor(data_all_l$frequency)
data_all_l$ear= factor(data_all_l$ear)
data_all_l <- na.omit(data_all_l)
#head(data_all_l)
```




```{r}
p <- data_all_l%>%
  mutate(frequency = fct_relevel(frequency,"250", "500", "1000", "2000", "4000", "8000")) %>%
  ggplot(aes(x = frequency, y = dB)) +
    #geom_bar(stat="identity") +
    #geom_histogram() +
    geom_violin() + 
    facet_wrap(~ group, ncol = 3) +
    #geom_point()
    xlab("Frequency (Hz)") +
    ylab("Hearing level (dB)") +
    scale_y_reverse(limits=c(130,-10)) 
    #theme_classic()
p
```

simple linear model: PTA is a function of the affected domain; here are two levels in this mixed model; 
1: timepoints for each patient; 2: genetic domain, with domain the fixed effect and patient the random effect allowing
the intercept to vary across patient (~1|pid).

```{r}
random_intercept <-lme(dB ~ frequency , 
            random = ~1|pid,   #p. 896
            method = "ML", 
            na.action = na.exclude, 
            control = list(opt="optim"),
            correlation = corAR1(),  #see p.897; timepoints are not equally spaced;use corCAR1 
            data = data_all_l)
summary(random_intercept)
anova(random_intercept)
```
now add Leeftijd as fixed effect; PTA ~ Domain + Leeftijd` (see. e.g. p.897)
```{r}
timeRI <- update(random_intercept, .~. + Leeftijd)
summary(timeRI)
```

```{r}
sessionInfo()
```

